tbilla = read.csv('TBill_Annual.csv')
tbillq = read.csv('TBill_Quarterly.csv')
#Fix dates and setup data
##################################
colnames(crsp)[1] <- "date"
colnames(tbilla)[1] <- "date"
colnames(tbillq)[1] <- "date"
crsp$date = ymd(crsp$date)
tbilla$date = ymd(tbilla$date)
tbillq$date = ymd(tbillq$date)
tbilla$year = year(tbilla$date)
tbillq$quarter = as.Date(as.yearqtr(tbillq$date))
crsp$quarter = as.Date(as.yearqtr(crsp$date))
crsp$year = year(crsp$date)
# Generate Dividend returns
crsp['div'] = ((crsp$vwretd + 1)/(crsp$vwretx + 1))-1
View(crsp)
crsp$logDiv = log(crsp$div + 1)
View(crspq)
# Generate Dividend returns
crsp['div'] = ((crsp$vwretd + 1)/(crsp$vwretx + 1))-1
# Check to see if Div returns are all positive
filter(crsp, div < 0)
crsp$vwretd = log(crsp$vwretd + 1)
crsp$vwretx = log(crsp$vwretx + 1)
crsp$logDiv = log(crsp$div + 1)
# Generate quarterly geometric cumulative sum
crspq = crsp %>%
group_by(quarter) %>%
summarise(vwretx = sum(vwretx),
vwretd = sum(vwretd),
logDiv = sum(div))
# Generate yearlt geometric cumulative sums
crspa = crsp %>%
group_by(year) %>%
summarise(vwretx = sum(vwretx),
vwretd = sum(vwretd),
logDiv = sum(div))
View(crspq)
crspq$x = 1 - crspq$logDiv
View(crspq)
View(crsp)
View(crsp)
library(ggplot2)
library(dplyr)
library(zoo)
library(lubridate)
library(plotly)
library(ts)
library(shiny)
library(PerformanceAnalytics)
#library(aTSA)
library(tseries)
setwd("C:\\Users\\austi\\Documents\\Github_Repos\\Macro_Finance\\Assignment-1\\Data")
# Helper Functions
############################################################
# Shortcut for making line charts
linePlot = function(x, y, xlabel, ylabel, title){
return(
plot_ly(x = x, y = y, type = "scatter", mode = 'lines') %>%
layout(
title = toString(title),
xaxis = list(title = xlabel),
yaxis = list(title = ylabel)
)
)
}
# Saves all of the plots names with 'plot(number)' to the WD
saveAllPlotsHtml = function(numPlots){
for(i in seq.int(numPlots)){
htmlwidgets::saveWidget(eval(parse(paste('plot', toString(i), sep =''))), paste('plot', toString(i), '.html', sep = ''))
}
}
# Returns the results from variously lagged linear regressions
regLaggedDiv = function(maxLag, dependent, independent){
coeffMatrix = list()
rSquared = list()
adjRsquared = list()
for(i in seq.int(maxLag)){
independent = lag(independent, k=i)
if(i == 1){
independent = independent[-i]
dependent = dependent[-i]
}
else{
independent = independent[-(1:i)]
dependent = dependent[-(1:i)]
}
coeffMatrix[[i]] = summary(lm(dependent ~ independent))$coefficients
rSquared[[i]] = summary(lm(dependent ~ independent))$r.squared
adjRsquared[[i]] = summary(lm(dependent ~ independent))$adj.r.squared
}
return(list(coeffMatrix, rSquared, adjRsquared))
}
###########################################################
crsp = read.csv('crsp_monthly.csv')
tbilla = read.csv('TBill_Annual.csv')
tbillq = read.csv('TBill_Quarterly.csv')
#Fix dates and setup data
##################################
colnames(crsp)[1] <- "date"
colnames(tbilla)[1] <- "date"
colnames(tbillq)[1] <- "date"
crsp$date = ymd(crsp$date)
tbilla$date = ymd(tbilla$date)
tbillq$date = ymd(tbillq$date)
tbilla$year = year(tbilla$date)
tbillq$quarter = as.Date(as.yearqtr(tbillq$date))
crsp$quarter = as.Date(as.yearqtr(crsp$date))
crsp$year = year(crsp$date)
#################################
# Generate Dividend returns
crsp['div'] = ((crsp$vwretd + 1)/(crsp$vwretx + 1))-1
View(crsp)
# Generate quarterly geometric cumulative sum
crspq = crsp %>%
group_by(quarter) %>%
summarise(vwretx = sum(vwretx) + 1,
vwretd = sum(vwretd) + 1,
logDiv = sum(div)) + 1
View(crspq)
# Generate quarterly geometric cumulative sum
crspq = crsp %>%
group_by(quarter) %>%
summarise(vwretx = sum(vwretx),
vwretd = sum(vwretd),
logDiv = sum(div))
library(ggplot2)
library(dplyr)
library(zoo)
library(lubridate)
library(plotly)
library(ts)
library(shiny)
library(PerformanceAnalytics)
#library(aTSA)
library(tseries)
setwd("C:\\Users\\austi\\Documents\\Github_Repos\\Macro_Finance\\Assignment-1\\Data")
# Helper Functions
############################################################
# Shortcut for making line charts
linePlot = function(x, y, xlabel, ylabel, title){
return(
plot_ly(x = x, y = y, type = "scatter", mode = 'lines') %>%
layout(
title = toString(title),
xaxis = list(title = xlabel),
yaxis = list(title = ylabel)
)
)
}
# Saves all of the plots names with 'plot(number)' to the WD
saveAllPlotsHtml = function(numPlots){
for(i in seq.int(numPlots)){
htmlwidgets::saveWidget(eval(parse(paste('plot', toString(i), sep =''))), paste('plot', toString(i), '.html', sep = ''))
}
}
# Returns the results from variously lagged linear regressions
regLaggedDiv = function(maxLag, dependent, independent){
coeffMatrix = list()
rSquared = list()
adjRsquared = list()
for(i in seq.int(maxLag)){
independent = lag(independent, k=i)
if(i == 1){
independent = independent[-i]
dependent = dependent[-i]
}
else{
independent = independent[-(1:i)]
dependent = dependent[-(1:i)]
}
coeffMatrix[[i]] = summary(lm(dependent ~ independent))$coefficients
rSquared[[i]] = summary(lm(dependent ~ independent))$r.squared
adjRsquared[[i]] = summary(lm(dependent ~ independent))$adj.r.squared
}
return(list(coeffMatrix, rSquared, adjRsquared))
}
###########################################################
crsp = read.csv('crsp_monthly.csv')
tbilla = read.csv('TBill_Annual.csv')
tbillq = read.csv('TBill_Quarterly.csv')
#Fix dates and setup data
##################################
colnames(crsp)[1] <- "date"
colnames(tbilla)[1] <- "date"
colnames(tbillq)[1] <- "date"
crsp$date = ymd(crsp$date)
tbilla$date = ymd(tbilla$date)
tbillq$date = ymd(tbillq$date)
tbilla$year = year(tbilla$date)
tbillq$quarter = as.Date(as.yearqtr(tbillq$date))
crsp$quarter = as.Date(as.yearqtr(crsp$date))
crsp$year = year(crsp$date)
#################################
# Generate Dividend returns
crsp['div'] = ((crsp$vwretd + 1)/(crsp$vwretx + 1))-1
# Check to see if Div returns are all positive
filter(crsp, div < 0)
#crsp$vwretd = log(crsp$vwretd + 1)
#crsp$vwretx = log(crsp$vwretx + 1)
#crsp$logDiv = log(crsp$div + 1)
################################################
# Generate quarterly geometric cumulative sum
crspq = crsp %>%
group_by(quarter) %>%
summarise(vwretx = Return.cumulative(vwretx, geometric = TRUE),
vwretd = Return.cumulative(vwretd, geometric = TRUE),
div = Return.cumulative(div, geometric = TRUE))
# Generate yearlt geometric cumulative sums
crspa = crsp %>%
group_by(year) %>%
summarise(vwretx = Return.cumulative(vwretx, geometric = TRUE),
vwretd = Return.cumulative(vwretd, geometric = TRUE),
div = Return.cumulative(div, geometric = TRUE))
crspq$vwretd +1
crspq$vwretx +1
crspa$vwretd +1
crspa$vwretx +1
# Join matching data based on the quarter and year dates
tbillq = left_join(tbillq, crspq, by = 'quarter')
tbilla = left_join(tbilla, crspa, by = 'year')
View(tbillq)
# Convert Simple returns (calculated by CRSP) to Log Returns: r = log(R + 1)
# Calculate the excess dividend inclusive index log return
tbillq$excessRetd = tbillq$vwretd - tbillq$t90ret
tbilla$excessRetd = tbilla$vwretd - tbilla$b1ret
rollingWindow = function(dependent, independent, window){
adjRsquared = c()
periodLength = length(dependent)
for(j in seq.int((periodLength - window))){
y = dependent[j:(j + window -1)]
x = independent[j:(j + window -1)]
adjRsquared[j] = summary(lm(y ~ x))$adj.r.squared
}
return(as.data.frame(adjRsquared))
}
View(tbilla)
rollingRsquaredd = rollingWindow(tbilla$excessRetd, tbilla$div, window = 15)
plot_ly(y = rollingRsquaredd$adjRsquared, y = row(rollingRsquaredd), type = "scatter", mode = 'lines') %>%
layout(
title = 'Adjusted R Squares: No Lagged Independent Variables'
)
rollingWindow = function(dependent, independent, window){
adjRsquared = c()
rSquared = c()
periodLength = length(dependent)
for(j in seq.int((periodLength - window))){
y = dependent[j:(j + window -1)]
x = independent[j:(j + window -1)]
reg = summary(lm(y ~ x))
adjRsquared[j] = reg$adj.r.squared
rSquared[j] = reg$r.squared
}
return(as.data.frame(adjRsquared, rSquared))
}
rollingRsquaredd = rollingWindow(tbilla$excessRetd, tbilla$div, window = 15)
rollingWindow = function(dependent, independent, window){
adjRsquared = c()
rSquared = c()
periodLength = length(dependent)
for(j in seq.int((periodLength - window))){
y = dependent[j:(j + window -1)]
x = independent[j:(j + window -1)]
reg = summary(lm(y ~ x))
adjRsquared[j] = reg$adj.r.squared
rSquared[j] = reg$r.squared
}
return(c(adjRsquared, rSquared))
}
rollingRsquaredd = rollingWindow(tbilla$excessRetd, tbilla$div, window = 15)
return(as.data.frame(rSquared))
rollingWindow = function(dependent, independent, window){
adjRsquared = c()
rSquared = c()
periodLength = length(dependent)
for(j in seq.int((periodLength - window))){
y = dependent[j:(j + window -1)]
x = independent[j:(j + window -1)]
reg = summary(lm(y ~ x))
adjRsquared[j] = reg$adj.r.squared
rSquared[j] = reg$r.squared
}
return(as.data.frame(rSquared))
}
rollingRsquaredd = rollingWindow(tbilla$excessRetd, tbilla$div, window = 15)
plot_ly(y = rollingRsquaredd$rSquared, y = row(rollingRsquaredd), type = "scatter", mode = 'lines') %>%
layout(
title = 'Adjusted R Squares: No Lagged Independent Variables'
)
rollingWindow = function(dependent, independent, window){
adjRsquared = c()
rSquared = c()
periodLength = length(dependent)
for(j in seq.int((periodLength - window))){
y = dependent[j:(j + window -1)]
x = independent[j:(j + window -1)]
reg = summary(lm(y ~ x))
adjRsquared[j] = reg$adj.r.squared
rSquared[j] = reg$r.squared
}
return(as.data.frame(rSquared, adjRsquared))
}
na.omit(tbilla)
tbilla = na.omit(tbilla)
rollingWindow = function(dependent, independent, window){
adjRsquared = c()
rSquared = c()
periodLength = length(dependent)
for(j in seq.int((periodLength - window))){
y = dependent[j:(j + window -1)]
x = independent[j:(j + window -1)]
reg = summary(lm(y ~ x))
adjRsquared[j] = reg$adj.r.squared
rSquared[j] = reg$r.squared
}
return(as.data.frame(rSquared, adjRsquared))
}
tbilla = na.omit(tbilla)
rollingRsquaredd = rollingWindow(tbilla$excessRetd, tbilla$div, window = 15)
rollingWindow = function(dependent, independent, window){
adjRsquared = c()
rSquared = c()
periodLength = length(dependent)
for(j in seq.int((periodLength - window))){
y = dependent[j:(j + window -1)]
x = independent[j:(j + window -1)]
reg = summary(lm(y ~ x))
adjRsquared[j] = reg$adj.r.squared
rSquared[j] = reg$r.squared
}
return(cbind.data.frame(rSquared, adjRsquared))
}
tbilla = na.omit(tbilla)
rollingRsquaredd = rollingWindow(tbilla$excessRetd, tbilla$div, window = 15)
View(rollingRsquaredd)
plot_ly(y = rollingRsquaredd$adjRsquared, name = 'Adjusted R Squared',
type = 'scatter', mode = 'lines') %>%
add_trace(y = rollingRsquaredd$rSquared, name = 'R Squared',
type = 'scatter', mode = 'lines') %>%
layout(
title = 'Rolling Window Regression: Dividends Inclusive, Lag: 0',
xaxis = list(title = 'Window Period'),
yaxis = list(title = 'R Squared Values')
)
rollingWindow = function(dependent, independent, window){
adjRsquared = c()
rSquared = c()
periodLength = length(dependent)
for(j in seq.int((periodLength - window))){
y = dependent[j:(j + window -1)]
x = independent[j:(j + window -1)]
reg = summary(lm(y ~ x))
print(reg)
adjRsquared[j] = reg$adj.r.squared
rSquared[j] = reg$r.squared
}
return(cbind.data.frame(rSquared, adjRsquared))
}
library(ggplot2)
library(dplyr)
library(zoo)
library(lubridate)
library(plotly)
library(ts)
library(shiny)
library(PerformanceAnalytics)
#library(aTSA)
library(tseries)
setwd("C:\\Users\\austi\\Documents\\Github_Repos\\Macro_Finance\\Assignment-1\\Data")
# Helper Functions
############################################################
# Shortcut for making line charts
linePlot = function(x, y, xlabel, ylabel, title){
return(
plot_ly(x = x, y = y, type = "scatter", mode = 'lines') %>%
layout(
title = toString(title),
xaxis = list(title = xlabel),
yaxis = list(title = ylabel)
)
)
}
# Saves all of the plots names with 'plot(number)' to the WD
saveAllPlotsHtml = function(numPlots){
for(i in seq.int(numPlots)){
htmlwidgets::saveWidget(eval(parse(paste('plot', toString(i), sep =''))), paste('plot', toString(i), '.html', sep = ''))
}
}
# Returns the results from variously lagged linear regressions
regLaggedDiv = function(maxLag, dependent, independent){
coeffMatrix = list()
rSquared = list()
adjRsquared = list()
for(i in seq.int(maxLag)){
independent = lag(independent, k=i)
if(i == 1){
independent = independent[-i]
dependent = dependent[-i]
}
else{
independent = independent[-(1:i)]
dependent = dependent[-(1:i)]
}
coeffMatrix[[i]] = summary(lm(dependent ~ independent))$coefficients
rSquared[[i]] = summary(lm(dependent ~ independent))$r.squared
adjRsquared[[i]] = summary(lm(dependent ~ independent))$adj.r.squared
}
return(list(coeffMatrix, rSquared, adjRsquared))
}
rollingWindow = function(dependent, independent, window){
adjRsquared = c()
rSquared = c()
periodLength = length(dependent)
for(j in seq.int((periodLength - window))){
y = dependent[j:(j + window -1)]
x = independent[j:(j + window -1)]
reg = summary(lm(y ~ x))
print(reg)
adjRsquared[j] = reg$adj.r.squared
rSquared[j] = reg$r.squared
}
return(cbind.data.frame(rSquared, adjRsquared))
}
rollingLag = function(maxLag, dependent, independent){
for(i in seq.int(maxLag)){
independent = lag(independent, k=i)
if(i == 1){
independent = independent[-i]
dependent = dependent[-i]
}
else{
independent = independent[-(1:i)]
dependent = dependent[-(1:i)]
}
}
}
###########################################################
crsp = read.csv('crsp_monthly.csv')
tbilla = read.csv('TBill_Annual.csv')
tbillq = read.csv('TBill_Quarterly.csv')
#Fix dates and setup data
##################################
colnames(crsp)[1] <- "date"
colnames(tbilla)[1] <- "date"
colnames(tbillq)[1] <- "date"
crsp$date = ymd(crsp$date)
tbilla$date = ymd(tbilla$date)
tbillq$date = ymd(tbillq$date)
tbilla$year = year(tbilla$date)
tbillq$quarter = as.Date(as.yearqtr(tbillq$date))
crsp$quarter = as.Date(as.yearqtr(crsp$date))
crsp$year = year(crsp$date)
#################################
# Generate Dividend returns
crsp['div'] = ((crsp$vwretd + 1)/(crsp$vwretx + 1))-1
# Check to see if Div returns are all positive
filter(crsp, div < 0)
#crsp$vwretd = log(crsp$vwretd + 1)
#crsp$vwretx = log(crsp$vwretx + 1)
#crsp$logDiv = log(crsp$div + 1)
################################################
# Generate quarterly geometric cumulative sum
crspq = crsp %>%
group_by(quarter) %>%
summarise(vwretx = Return.cumulative(vwretx, geometric = TRUE) + 1,
vwretd = Return.cumulative(vwretd, geometric = TRUE) + 1,
div = Return.cumulative(div, geometric = TRUE)) + 1
# Generate yearlt geometric cumulative sums
crspa = crsp %>%
group_by(year) %>%
summarise(vwretx = Return.cumulative(vwretx, geometric = TRUE) + 1,
vwretd = Return.cumulative(vwretd, geometric = TRUE) + 1,
div = Return.cumulative(div, geometric = TRUE)) + 1
View(crspa)
View(crspq)
# Generate quarterly geometric cumulative sum
crspq = crsp %>%
group_by(quarter) %>%
summarise(vwretx = Return.cumulative(vwretx, geometric = TRUE),
vwretd = Return.cumulative(vwretd, geometric = TRUE),
div = Return.cumulative(div, geometric = TRUE))
# Generate yearlt geometric cumulative sums
crspa = crsp %>%
group_by(year) %>%
summarise(vwretx = Return.cumulative(vwretx, geometric = TRUE),
vwretd = Return.cumulative(vwretd, geometric = TRUE),
div = Return.cumulative(div, geometric = TRUE))
crspa$vwretd = crspa$vwretd + 1
crspa$div = crspa$div + 1
tbilla = left_join(tbilla, crspa, by = 'year')
View(tbilla)
# Convert Simple returns (calculated by CRSP) to Log Returns: r = log(R + 1)
# Calculate the excess dividend inclusive index log return
tbillq$excessRetd = tbillq$vwretd - tbillq$t90ret
tbilla$excessRetd = tbilla$vwretd - tbilla$b1ret
tbilla = na.omit(tbilla)
rollingRsquaredd = rollingWindow(tbilla$excessRetd, tbilla$div, window = 15)
plot_ly(y = rollingRsquaredd$adjRsquared, name = 'Adjusted R Squared',
type = 'scatter', mode = 'lines') %>%
add_trace(y = rollingRsquaredd$rSquared, name = 'R Squared',
type = 'scatter', mode = 'lines') %>%
layout(
title = 'Rolling Window Regression: Dividends Inclusive, Lag: 0',
xaxis = list(title = 'Window Period'),
yaxis = list(title = 'R Squared Values')
)
crspa$div = log(crspa$div + 1)
tbilla = left_join(tbilla, crspa, by = 'year')
# Convert Simple returns (calculated by CRSP) to Log Returns: r = log(R + 1)
# Calculate the excess dividend inclusive index log return
tbillq$excessRetd = log(tbillq$vwretd - tbillq$t90ret + 1)
